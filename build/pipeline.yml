# Azure DevOps pipeline file using Taskfile as the runner
# This is so that the main build and tests can be run in the same way
# on a local machine as well as in the CLI

# Set the name which will define the build number
name: $(version_semver)

parameters:
  - name: pre_release
    displayName: Create a pre-release from a feature branch
    type: boolean
    default: false

  - name: generate_docs
    type: boolean
    default: true
    displayName: Generate Documentation

variables:
  - template: variables.yml

stages:
  - stage: prelim
    displayName: Preliminaries

    jobs:
      - job: version_number
        displayName: Set Build Number
        pool:
          vmImage: $(pool_vm_image)

        steps:
          - template: templates/setup.yml
            parameters:
              EirctlVersion: $(EirctlVersion)

          # Update the build number
          - task: Bash@3
            displayName: Set Build Number
            inputs:
              targetType: inline
              script: |
                eirctl build:number

          - task: Bash@3
            displayName: Perform YAML linting
            inputs:
              targetType: inline
              script: |
                eirctl lint:yaml


  - stage: docs
    displayName: Documentation
    condition: and(succeeded(), eq(${{ parameters.generate_docs }}, true))
    dependsOn:
      - prelim

    jobs:
      - job: generate_docs
        displayName: Generate Documentation
        pool:
          vmImage: $(pool_vm_image)

        steps:
          - template: templates/setup.yml
            parameters:
              EirctlVersion: $(EirctlVersion)

          - task: Bash@3
            displayName: Generate Documentation
            inputs:
              targetType: inline
              script: |
                eirctl _docs
            env:
              BUILDNUMBER: $(Build.BuildNumber)

          # Upload the documentation as a pipeline artifact
          - task: PublishBuildArtifacts@1
            displayName: Publish Documentation
            inputs:
              pathToPublish: $(Build.SourcesDirectory)/outputs/docs
              artifactName: docs

  - stage: build
    displayName: Build
    dependsOn:
      - prelim

    jobs:
      - job: Build
        pool:
          vmImage: $(pool_vm_image)

        steps:
          # Install Eirctl for the build to run
          - template: templates/setup.yml
            parameters:
              EirctlVersion: $(EirctlVersion)

          # Clean the environment before running tests and compiling the application
          - task: Bash@3
            displayName: Build & Test
            inputs:
              targetType: inline
              script: |
                eirctl clean

          # Run the Unit tests for the application
          - task: Bash@3
            displayName: Run Unit Tests
            inputs:
              targetType: inline
              script: |
                eirctl test:unit

          # Compile the application
          - task: Bash@3
            displayName: Build
            inputs:
              targetType: inline
              script: |
                eirctl _compile

          - task: Bash@3
            displayName: Outputs
            inputs:
              targetType: inline
              script: |
                tree outputs

          # Upload the tests and the coverage
          - task: PublishTestResults@2
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: $(Build.SourcesDirectory)/outputs/tests/report.xml
              testRunTitle: UnitTests

          - task: PublishCodeCoverageResults@2
            inputs:
              codeCoverageTool: Cobertura
              summaryFileLocation: $(Build.SourcesDirectory)/outputs/tests/coverage.xml

          # Upload the binary files
          - task: PublishBuildArtifacts@1
            displayName: Publish Binaries
            inputs:
              pathToPublish: $(Build.SourcesDirectory)/outputs/bin
              artifactName: StacksCLI

  - stage: int_tests
    displayName: Integration Tests
    dependsOn:
      - build
    condition: succeeded()

    jobs:
      - job: IntegrationTests
        pool:
          vmImage: $(pool_vm_image)

        steps:
          # Download the StacksCLI and the integration_tests
          - task: DownloadPipelineArtifact@2
            inputs:
              artifact: StacksCLI
              path: $(Build.SourcesDirectory)/outputs/bin

          # Install Eirctl for the build to run
          - template: templates/setup.yml
            parameters:
              EirctlVersion: $(EirctlVersion)

          # Run the integration tests
          - task: Bash@3
            displayName: Execute Tests
            inputs:
              targetType: inline
              script: |
                export GOBIN=$HOME/go/bin
                export PATH=$PATH:$GOBIN
                eirctl test:int
            env:
              BIN_DIR: $(Build.ArtifactStagingDirectory)/bin
              BUILDNUMBER: $(Build.BuildNumber)
              WORKING_DIR: $(Build.SourcesDirectory)/projects

          - task: Bash@3
            displayName: Generate Report
            inputs:
              targetType: inline
              script: |
                export GOBIN=$HOME/go/bin
                export PATH=$PATH:$GOBIN
                eirctl test:int:generate_report
            env:
              BIN_DIR: $(Build.ArtifactStagingDirectory)/bin
              BUILDNUMBER: $(Build.BuildNumber)
              WORKING_DIR: $(Build.SourcesDirectory)/projects

          # Upload the integration test results
          - task: PublishTestResults@2
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: $(Build.SourcesDirectory)/outputs/tests/integration_test_report.xml
              testRunTitle: IntegrationTests

  - stage: Release
    dependsOn:
      - int_tests
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(${{ parameters.pre_release }}, true)))

    variables:
      - group: github-creds

    jobs:
      - job: CreateGHRelease
        pool:
          vmImage: $(pool_vm_image)

        steps:
          # Download the necessary artifacts from the previous stage
          # - documentation
          - task: DownloadPipelineArtifact@2
            inputs:
              artifact: "docs"
              patterns: "**/*.pdf"
              path: $(Build.SourcesDirectory)/outputs/assets

          - task: DownloadPipelineArtifact@2
            inputs:
              artifact: "StacksCLI"
              path: $(Build.SourcesDirectory)/outputs/assets
              patterns: |
                **
                !**/*inttest*

          # Install Eirctl for the build to run
          - template: templates/setup.yml
            parameters:
              EirctlVersion: $(EirctlVersion)

          # Run the tasks to build the application
          - task: Bash@3
            displayName: Release
            inputs:
              targetType: inline
              script: |
                eirctl release
            env:
              STAGE: "release"
              PUBLISH_RELEASE: "true"
              GITHUB_TOKEN: "$(GITHUB_TOKEN)"
              OWNER: $(RepoOwner)
              REPOSITORY: $(RepoName)
              BUILD_BUILDNUMBER: $(BUILD_BUILDNUMBER)
              COMMIT_ID: $(Build.SourceVersion)
              ARTIFACTS_DIR: /eirctl/outputs/assets
              ${{ if ne(variables['Build.SourceBranch'], 'refs/heads/main') }}:
                PRERELEASE: "true"
